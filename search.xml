<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CTF逆向入门</title>
    <url>/2022/09/27/Introduction/</url>
    <content><![CDATA[<h2 id="This-is-a-new-starting-point"><a href="#This-is-a-new-starting-point" class="headerlink" title="This is a new starting point."></a>This is a new starting point.</h2><h2 id="Welcome-to-a-new-world"><a href="#Welcome-to-a-new-world" class="headerlink" title="Welcome to a new world!_"></a>Welcome to a new world!_</h2><h4 id="Some-other-web-sites"><a href="#Some-other-web-sites" class="headerlink" title="Some other web sites:"></a>Some other web sites:</h4><ul>
<li><a href="https://blog.csdn.net/qq_59700927?spm=1000.2115.3001.5343">CSDN</a></li>
<li><a href="https://www.zhihu.com/people/woodenman-15">知乎</a></li>
<li><a href="https://github.com/Blockhead1DLW">Github</a></li>
</ul>
<blockquote>
<p>If the picture cannot be loaded, it can be determined that your site is in China</p>
</blockquote>
<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>用这篇文章来浅谈一下逆向吧<br>如果你是大一，那你可能会遇到一些麻烦，一下子接触这么多语言，接触这么多配置方式。<br>我只能说，不要急，慢慢来</p>
<h2 id="序序言"><a href="#序序言" class="headerlink" title="序序言"></a>序序言</h2><blockquote>
<p>你可以不会汇编，但是你不可以不会c语言</p>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>你应该干什么？</p>
<ol>
<li>在展开正式学习之前，先试着去安装一个kali 和win10虚拟机，这是必要的</li>
<li>关于ctf-wiki，我们需要看，看一看逆向简介即可，剩余的如果你想看的话，可以看看目录</li>
<li>安装工具</li>
<li>开始学习<ol>
<li>学会使用工具(目的在于学会工具使用，而不是看懂代码)</li>
</ol>
<ul>
<li>exe文件执行与反编</li>
<li>elf文件执行与反编</li>
<li>jar文件执行与反编</li>
<li>pyc文件反编与编译运行</li>
<li>apk文件反编<blockquote>
<p>或许你不能完全的完成上面的事情，但这并不影响你继续后面的步骤</p>
</blockquote>
</li>
</ul>
<ol>
<li>了解一些常见的加密方式，tea，xtea，base64等等</li>
<li>python，java语言学习，先了解基本语法，此外，用python写一些简单的脚本（记住循序渐进）</li>
<li>汇编语言（功底越深越好）</li>
<li>看CTF-wiki，到这里你已经有了一些功底，是时候加深了解逆向了。浅浅接触一下花指令、加脱壳、反调试技术等等，你或许会发现自己看不懂，别急，看不懂的就是我们接下来要学习的</li>
<li>看过wiki之后，我想你明白了逆向有windows逆向，linux逆向，Android逆向，Ios逆向<blockquote>
<p>到这里，如果你在学习时同时刷了足够多的题，那我想你应该知道你接下来要做什么了</p>
</blockquote>
</li>
<li>尝试破解一些简单的软件之类(不要去违法)</li>
<li>刷题 &amp; 底层学习</li>
</ol>
</li>
</ol>
<h2 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h2><ul>
<li>逆向是一个需要代码能力较强的方向，最后你一定能够依靠的，是汇编，所以，学好汇编</li>
<li>多刷题，逆向要做的事就决定了他需要积攒足够的经验，因为你也不知道你下一秒遇到的软件是哪个奇葩开发的</li>
<li>多去论坛转悠转悠，会有帮助</li>
<li>不要执着于一个点，要学会取舍</li>
</ul>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>记住，能轻易完成的工作，也是最容易被替代的工作，我们要成为的，不是被替代的人。‘</p>
]]></content>
      <categories>
        <category>Welcome</category>
      </categories>
  </entry>
  <entry>
    <title>工具汇总</title>
    <url>/2022/09/18/Tools/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>这篇文章主要把逆向和密码学需要用到的工具汇总一下</li>
<li>如果引用内容侵权，请联系删除</li>
<li>安装过程一般不做说明，google即可</li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><ul>
<li><p>虚拟机下载<br><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华源</a><br><a href="https://developer.aliyun.com/mirror">阿里源</a></p>
</li>
<li><p>exeinfope(查壳工具)</p>
<blockquote>
<p>链接：(<a href="https://pan.baidu.com/s/1oXarqcAuWdXWTB-8830q0Q?pwd=1234">https://pan.baidu.com/s/1oXarqcAuWdXWTB-8830q0Q?pwd=1234</a>)<br>提取码：1234</p>
</blockquote>
</li>
<li><p>PEiD(查壳工具)</p>
<blockquote>
<p>链接：(<a href="https://pan.baidu.com/s/15vWG_e4qcNi_McHmdiTPkg?pwd=1234">https://pan.baidu.com/s/15vWG_e4qcNi_McHmdiTPkg?pwd=1234</a>)<br>提取码：1234</p>
</blockquote>
</li>
<li><p>IDA7.2(静态调试工具)</p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1fADIonw9sSyZ1pFIDkeBXg?pwd=1234">https://pan.baidu.com/s/1fADIonw9sSyZ1pFIDkeBXg?pwd=1234</a><br>提取码：1234</p>
</blockquote>
</li>
<li><p>Ollydbg(动态调试工具)<br><a href="https://www.52pojie.cn/thread-350397-1-1.html">吾爱破解</a></p>
</li>
<li><p>x64dbg(动态调试工具)[工具来源于吾爱破解]</p>
<blockquote>
<p>链接：(<a href="https://pan.baidu.com/s/1aG_nczhG8mOqDBvOZMzyYg?pwd=1234">https://pan.baidu.com/s/1aG_nczhG8mOqDBvOZMzyYg?pwd=1234</a>)<br>提取码：1234 </p>
</blockquote>
</li>
<li><p>Ghidra(静态调试工具)</p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1fr1TeZUrdzD-VZHnWbl57w?pwd=1234">https://pan.baidu.com/s/1fr1TeZUrdzD-VZHnWbl57w?pwd=1234</a><br>提取码：1234</p>
</blockquote>
</li>
<li><p>cheat engine(内存修改工具)<br>官方网站-(<a href="https://cheatengine.org/">https://cheatengine.org/</a>)</p>
</li>
<li><p>upx加脱壳</p>
<blockquote>
<p>链接：(<a href="https://pan.baidu.com/s/1LqzAz1arZqpbEBEHZrRsBg?pwd=1234">https://pan.baidu.com/s/1LqzAz1arZqpbEBEHZrRsBg?pwd=1234</a>)<br>提取码：1234</p>
</blockquote>
</li>
<li><p>upx shell</p>
<blockquote>
<p>链接：(<a href="https://pan.baidu.com/s/195lxQRjBB39H_RA46SWxpg?pwd=1234">https://pan.baidu.com/s/195lxQRjBB39H_RA46SWxpg?pwd=1234</a>)<br>提取码：1234 </p>
</blockquote>
</li>
<li><p>upx<br>官方网站-(<a href="https://upx.github.io/">https://upx.github.io</a>)</p>
</li>
<li><p>PEview(查看PE文件结构)</p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1JGCcCVmR5nUOJbkM5OzQ5w?pwd=1234">https://pan.baidu.com/s/1JGCcCVmR5nUOJbkM5OzQ5w?pwd=1234</a><br>提取码：1234 </p>
</blockquote>
</li>
<li><p>Winhex(十六进制查看器)</p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1NLyr9YsQ1DNAOTPyY02hBA?pwd=1234">https://pan.baidu.com/s/1NLyr9YsQ1DNAOTPyY02hBA?pwd=1234</a><br>提取码：1234</p>
</blockquote>
</li>
<li><p>010 Editor(十六进制查看器)</p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1o1X7FKxfOUZsOkGxi22Ttg?pwd=1234">https://pan.baidu.com/s/1o1X7FKxfOUZsOkGxi22Ttg?pwd=1234</a><br>提取码：1234</p>
</blockquote>
</li>
<li><p>APKTOOLS(反编译android apk)<br>官方网站-(<a href="https://ibotpeaches.github.io/Apktool/install/">https://ibotpeaches.github.io/Apktool/install/</a>)</p>
</li>
<li><p>Dex2jar(打包dex文件为jar)<br> SOURCEFORGE-(<a href="https://sourceforge.net/projects/dex2jar">https://sourceforge.net/projects/dex2jar</a>)</p>
</li>
<li><p>JD-GUIjar(反编译jar文件)</p>
</li>
<li><p>jeb(apk反编)<br>看雪社区搜索破解</p>
</li>
</ul>
<h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><ul>
<li><p>z3(解方程工具)</p>
<blockquote>
<p>链接：(<a href="https://pan.baidu.com/s/1gni_eYUC-Y_dQVogJh9QyA?pwd=1234">https://pan.baidu.com/s/1gni_eYUC-Y_dQVogJh9QyA?pwd=1234</a>)<br>提取码：1234</p>
</blockquote>
</li>
<li><p>Ziperello(zip加密暴力破解)</p>
<blockquote>
<p>链接：(<a href="https://pan.baidu.com/s/1of_e5mleYDPjZGZxiYi63Q?pwd=1234">https://pan.baidu.com/s/1of_e5mleYDPjZGZxiYi63Q?pwd=1234</a>)<br>提取码：1234</p>
</blockquote>
</li>
<li><p>Converter(编码转换工具)</p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1hzK04wmtm4rWsNyofqXPxw?pwd=1234">https://pan.baidu.com/s/1hzK04wmtm4rWsNyofqXPxw?pwd=1234</a><br>提取码：1234</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>CTF——工具</category>
      </categories>
  </entry>
  <entry>
    <title>RoarCTF2019 polyre</title>
    <url>/2022/11/08/Solve2/</url>
    <content><![CDATA[<h2 id="解题流程"><a href="#解题流程" class="headerlink" title="解题流程"></a>解题流程</h2><ol>
<li>查壳IDA</li>
<li>脚本去平坦化</li>
<li>IDA脚本去混淆</li>
<li>CRC32识别</li>
<li>解密脚本</li>
</ol>
<h2 id="脚本集"><a href="#脚本集" class="headerlink" title="脚本集"></a>脚本集</h2><ul>
<li><p>去平坦化脚本</p>
<ul>
<li><p>命令：</p>
<blockquote>
<p>python deflat.py attachment 0x400620</p>
</blockquote>
</li>
<li><p>deflat</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> pyvex</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;C:\\Users\\du\\Desktop\\CTFTools\\Flat\\am_graph&#x27;</span>)  <span class="comment">## am_graph路径</span></span><br><span class="line"><span class="keyword">import</span> am_graph</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.getLogger(<span class="string">&#x27;angr.state_plugins.symbolic_memory&#x27;</span>).setLevel(logging.ERROR)</span><br><span class="line"><span class="comment"># logging.getLogger(&#x27;angr.sim_manager&#x27;).setLevel(logging.DEBUG)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_relevant_nop_nodes</span>(<span class="params">supergraph</span>):</span><br><span class="line">    <span class="keyword">global</span> pre_dispatcher_node, prologue_node, retn_node</span><br><span class="line">    <span class="comment"># relevant_nodes = list(supergraph.predecessors(pre_dispatcher_node))</span></span><br><span class="line">    relevant_nodes = []</span><br><span class="line">    nop_nodes = []</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> supergraph.nodes():</span><br><span class="line">        <span class="keyword">if</span> supergraph.has_edge(node, pre_dispatcher_node) <span class="keyword">and</span> node.size &gt; <span class="number">8</span>:</span><br><span class="line">            <span class="comment"># <span class="doctag">XXX:</span> use node.size is faster than to create a block </span></span><br><span class="line">            relevant_nodes.append(node)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> node.addr <span class="keyword">in</span> ( prologue_node.addr, retn_node.addr, pre_dispatcher_node.addr):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        nop_nodes.append(node)</span><br><span class="line">    <span class="keyword">return</span> relevant_nodes, nop_nodes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">symbolic_execution</span>(<span class="params">start_addr, hook_addr=<span class="literal">None</span>, modify=<span class="literal">None</span>, inspect=<span class="literal">False</span></span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">retn_procedure</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">global</span> project</span><br><span class="line">        ip = state.se.<span class="built_in">eval</span>(state.regs.ip)</span><br><span class="line">        project.unhook(ip)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">statement_inspect</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">global</span> modify_value</span><br><span class="line">        expressions = <span class="built_in">list</span>(state.scratch.irsb.statements[state.inspect.statement].expressions)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(expressions) != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">isinstance</span>(expressions[<span class="number">0</span>], pyvex.expr.ITE):</span><br><span class="line">            state.scratch.temps[expressions[<span class="number">0</span>].cond.tmp] = modify_value</span><br><span class="line">            state.inspect._breakpoints[<span class="string">&#x27;statement&#x27;</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> project, relevant_block_addrs, modify_value</span><br><span class="line">    <span class="keyword">if</span> hook_addr != <span class="literal">None</span>:</span><br><span class="line">        project.hook(hook_addr, retn_procedure, length=<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> modify != <span class="literal">None</span>:</span><br><span class="line">        modify_value = modify</span><br><span class="line">    state = project.factory.blank_state(addr=start_addr, remove_options=&#123;angr.sim_options.LAZY_SOLVES&#125;)</span><br><span class="line">    <span class="keyword">if</span> inspect:</span><br><span class="line">        state.inspect.b(<span class="string">&#x27;statement&#x27;</span>, when=angr.state_plugins.inspect.BP_BEFORE, action=statement_inspect)</span><br><span class="line">    sm = project.factory.simulation_manager(state)</span><br><span class="line">    sm.step()</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(sm.active) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> active_state <span class="keyword">in</span> sm.active:</span><br><span class="line">            <span class="keyword">if</span> active_state.addr <span class="keyword">in</span> relevant_block_addrs:</span><br><span class="line">                <span class="keyword">return</span> active_state.addr</span><br><span class="line">        sm.step()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill_nop</span>(<span class="params">data, start_addr, length</span>):</span><br><span class="line">    <span class="keyword">global</span> opcode</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length):</span><br><span class="line">        data[start_addr + i] = <span class="built_in">ord</span>(opcode[<span class="string">&#x27;nop&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill_jmp_offset</span>(<span class="params">data, start, offset</span>):</span><br><span class="line">    jmp_offset = struct.pack(<span class="string">&#x27;&lt;i&#x27;</span>, offset)  <span class="comment"># bytes</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        data[start + i] = jmp_offset[i]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">patch_byte</span>(<span class="params">data, offset, value</span>):</span><br><span class="line">    <span class="comment"># operate on bytearray, not str</span></span><br><span class="line">    data[offset] = <span class="built_in">ord</span>(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Usage: python deflat.py filename function_address(hex)&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    opcode = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;\x87&#x27;</span>, <span class="string">&#x27;ae&#x27;</span>: <span class="string">&#x27;\x83&#x27;</span>, <span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;\x82&#x27;</span>, <span class="string">&#x27;be&#x27;</span>:<span class="string">&#x27;\x86&#x27;</span>, <span class="string">&#x27;c&#x27;</span>:<span class="string">&#x27;\x82&#x27;</span>, <span class="string">&#x27;e&#x27;</span>:<span class="string">&#x27;\x84&#x27;</span>, <span class="string">&#x27;z&#x27;</span>:<span class="string">&#x27;\x84&#x27;</span>, <span class="string">&#x27;g&#x27;</span>:<span class="string">&#x27;\x8F&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;ge&#x27;</span>:<span class="string">&#x27;\x8D&#x27;</span>, <span class="string">&#x27;l&#x27;</span>:<span class="string">&#x27;\x8C&#x27;</span>, <span class="string">&#x27;le&#x27;</span>:<span class="string">&#x27;\x8E&#x27;</span>, <span class="string">&#x27;na&#x27;</span>:<span class="string">&#x27;\x86&#x27;</span>, <span class="string">&#x27;nae&#x27;</span>:<span class="string">&#x27;\x82&#x27;</span>, <span class="string">&#x27;nb&#x27;</span>:<span class="string">&#x27;\x83&#x27;</span>, <span class="string">&#x27;nbe&#x27;</span>:<span class="string">&#x27;\x87&#x27;</span>, <span class="string">&#x27;nc&#x27;</span>:<span class="string">&#x27;\x83&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;ne&#x27;</span>:<span class="string">&#x27;\x85&#x27;</span>, <span class="string">&#x27;ng&#x27;</span>:<span class="string">&#x27;\x8E&#x27;</span>, <span class="string">&#x27;nge&#x27;</span>:<span class="string">&#x27;\x8C&#x27;</span>, <span class="string">&#x27;nl&#x27;</span>:<span class="string">&#x27;\x8D&#x27;</span>, <span class="string">&#x27;nle&#x27;</span>:<span class="string">&#x27;\x8F&#x27;</span>, <span class="string">&#x27;no&#x27;</span>:<span class="string">&#x27;\x81&#x27;</span>, <span class="string">&#x27;np&#x27;</span>:<span class="string">&#x27;\x8B&#x27;</span>, <span class="string">&#x27;ns&#x27;</span>:<span class="string">&#x27;\x89&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;nz&#x27;</span>:<span class="string">&#x27;\x85&#x27;</span>, <span class="string">&#x27;o&#x27;</span>:<span class="string">&#x27;\x80&#x27;</span>, <span class="string">&#x27;p&#x27;</span>:<span class="string">&#x27;\x8A&#x27;</span>, <span class="string">&#x27;pe&#x27;</span>:<span class="string">&#x27;\x8A&#x27;</span>, <span class="string">&#x27;po&#x27;</span>:<span class="string">&#x27;\x8B&#x27;</span>, <span class="string">&#x27;s&#x27;</span>:<span class="string">&#x27;\x88&#x27;</span>, <span class="string">&#x27;nop&#x27;</span>:<span class="string">&#x27;\x90&#x27;</span>, <span class="string">&#x27;jmp&#x27;</span>:<span class="string">&#x27;\xE9&#x27;</span>, <span class="string">&#x27;j&#x27;</span>:<span class="string">&#x27;\x0F&#x27;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">    start = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    project = angr.Project(filename, load_options=&#123;<span class="string">&#x27;auto_load_libs&#x27;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">    cfg = project.analyses.CFGFast(normalize=<span class="literal">True</span>)  <span class="comment"># do normalize to avoid overlapping blocks</span></span><br><span class="line">    target_function = cfg.functions.get(start)</span><br><span class="line">    <span class="comment"># A super transition graph is a graph that looks like IDA Pro&#x27;s CFG</span></span><br><span class="line">    supergraph = am_graph.to_supergraph(target_function.transition_graph)</span><br><span class="line"></span><br><span class="line">    base_addr = project.loader.main_object.mapped_base &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get prologue_node and retn_node</span></span><br><span class="line">    prologue_node = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> supergraph.nodes():</span><br><span class="line">        <span class="keyword">if</span> supergraph.in_degree(node) == <span class="number">0</span>:</span><br><span class="line">            prologue_node = node</span><br><span class="line">        <span class="keyword">if</span> supergraph.out_degree(node) == <span class="number">0</span>:</span><br><span class="line">            retn_node = node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> prologue_node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> prologue_node.addr != start:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something must be wrong...&quot;</span>)</span><br><span class="line">        sys.exit(-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    main_dispatcher_node = <span class="built_in">list</span>(supergraph.successors(prologue_node))[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> supergraph.predecessors(main_dispatcher_node):</span><br><span class="line">        <span class="keyword">if</span> node.addr != prologue_node.addr:</span><br><span class="line">            pre_dispatcher_node = node</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    relevant_nodes, nop_nodes = get_relevant_nop_nodes(supergraph)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;*******************relevant blocks************************&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;prologue: %#x&#x27;</span> % start)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main_dispatcher: %#x&#x27;</span> % main_dispatcher_node.addr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;pre_dispatcher: %#x&#x27;</span> % pre_dispatcher_node.addr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;retn: %#x&#x27;</span> % retn_node.addr)</span><br><span class="line">    relevant_block_addrs = [node.addr <span class="keyword">for</span> node <span class="keyword">in</span> relevant_nodes]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;relevant_blocks:&#x27;</span>, [<span class="built_in">hex</span>(addr) <span class="keyword">for</span> addr <span class="keyword">in</span> relevant_block_addrs])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;*******************symbolic execution*********************&#x27;</span>)</span><br><span class="line">    relevants = relevant_nodes</span><br><span class="line">    relevants.append(prologue_node)</span><br><span class="line">    relevants_without_retn = <span class="built_in">list</span>(relevants)</span><br><span class="line">    relevants.append(retn_node)</span><br><span class="line">    relevant_block_addrs.extend([prologue_node.addr, retn_node.addr])</span><br><span class="line"></span><br><span class="line">    flow = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    modify_value = <span class="literal">None</span></span><br><span class="line">    patch_instrs = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> relevant <span class="keyword">in</span> relevants_without_retn:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-------------------dse %#x---------------------&#x27;</span> % relevant.addr)</span><br><span class="line">        block = project.factory.block(relevant.addr, size=relevant.size)</span><br><span class="line">        has_branches = <span class="literal">False</span></span><br><span class="line">        hook_addr = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> ins <span class="keyword">in</span> block.capstone.insns:</span><br><span class="line">            <span class="keyword">if</span> ins.insn.mnemonic.startswith(<span class="string">&#x27;cmov&#x27;</span>):</span><br><span class="line">                patch_instrs[relevant] = ins</span><br><span class="line">                has_branches = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> ins.insn.mnemonic.startswith(<span class="string">&#x27;call&#x27;</span>):</span><br><span class="line">                hook_addr = ins.insn.address</span><br><span class="line">        <span class="keyword">if</span> has_branches:</span><br><span class="line">            flow[relevant].append(symbolic_execution(relevant.addr, hook_addr, claripy.BVV(<span class="number">1</span>, <span class="number">1</span>), <span class="literal">True</span>))</span><br><span class="line">            flow[relevant].append(symbolic_execution(relevant.addr, hook_addr, claripy.BVV(<span class="number">0</span>, <span class="number">1</span>), <span class="literal">True</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flow[relevant].append(symbolic_execution(relevant.addr, hook_addr))</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;************************flow******************************&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> flow.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%#x: &#x27;</span> % k.addr, [<span class="built_in">hex</span>(child) <span class="keyword">for</span> child <span class="keyword">in</span> v])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># print retn_node flow. Actually, it&#x27;s [].</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%#x: &#x27;</span> % retn_node.addr, [])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;************************patch*****************************&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> origin:</span><br><span class="line">        <span class="comment"># Attention: can&#x27;t transform to str by calling decode() directly. so use bytearray instead.</span></span><br><span class="line">        origin_data = <span class="built_in">bytearray</span>(origin.read())</span><br><span class="line">        origin_data_len = <span class="built_in">len</span>(origin_data)</span><br><span class="line"></span><br><span class="line">    recovery_file = filename + <span class="string">&#x27;_recovered&#x27;</span></span><br><span class="line">    recovery = <span class="built_in">open</span>(recovery_file, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># patch irrelevant blocks</span></span><br><span class="line">    <span class="keyword">for</span> nop_node <span class="keyword">in</span> nop_nodes:</span><br><span class="line">        fill_nop(origin_data, nop_node.addr - base_addr, nop_node.size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># remove unnecessary control flows</span></span><br><span class="line">    <span class="keyword">for</span> parent, childs <span class="keyword">in</span> flow.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(childs) == <span class="number">1</span>:</span><br><span class="line">            parent_block = project.factory.block(parent.addr, size=parent.size)</span><br><span class="line">            last_instr = parent_block.capstone.insns[-<span class="number">1</span>]</span><br><span class="line">            file_offset = last_instr.address - base_addr</span><br><span class="line">            <span class="comment"># patch the last jmp instruction</span></span><br><span class="line">            patch_byte(origin_data, file_offset, opcode[<span class="string">&#x27;jmp&#x27;</span>])</span><br><span class="line">            file_offset += <span class="number">1</span></span><br><span class="line">            fill_nop(origin_data, file_offset, last_instr.size - <span class="number">1</span>)</span><br><span class="line">            fill_jmp_offset(origin_data, file_offset, childs[<span class="number">0</span>] - last_instr.address - <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            instr = patch_instrs[parent]</span><br><span class="line">            file_offset = instr.address - base_addr</span><br><span class="line">            <span class="comment"># patch instructions starting from `cmovx` to the end of block</span></span><br><span class="line">            fill_nop(origin_data, file_offset, parent.addr + parent.size - base_addr - file_offset)</span><br><span class="line">            patch_byte(origin_data, file_offset, opcode[<span class="string">&#x27;j&#x27;</span>])</span><br><span class="line">            patch_byte(origin_data, file_offset + <span class="number">1</span>, opcode[instr.mnemonic[<span class="number">4</span>:]])</span><br><span class="line">            fill_jmp_offset(origin_data, file_offset + <span class="number">2</span>, childs[<span class="number">0</span>] - instr.address - <span class="number">6</span>)</span><br><span class="line">            file_offset += <span class="number">6</span></span><br><span class="line">            patch_byte(origin_data, file_offset, opcode[<span class="string">&#x27;jmp&#x27;</span>])</span><br><span class="line">            fill_jmp_offset(origin_data, file_offset + <span class="number">1</span>, childs[<span class="number">1</span>] - (instr.address + <span class="number">6</span>) - <span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(origin_data) == origin_data_len, <span class="string">&quot;Error: size of data changed!!!&quot;</span></span><br><span class="line">    recovery.write(origin_data)</span><br><span class="line">    recovery.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Successful! The recovered file: %s&#x27;</span> % recovery_file)</span><br></pre></td></tr></table></figure>
</li>
<li><p>am_graph</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> networkx</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> angr.knowledge_plugins <span class="keyword">import</span> Function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grouper</span>(<span class="params">iterable, n, fillvalue=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;Collect data into fixed-length chunks or blocks&quot;</span></span><br><span class="line">    args = [<span class="built_in">iter</span>(iterable)] * n</span><br><span class="line">    <span class="keyword">return</span> itertools.izip_longest(*args, fillvalue=fillvalue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_supergraph</span>(<span class="params">transition_graph</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Convert transition graph of a function to a super transition graph. A super transition graph is a graph that looks</span></span><br><span class="line"><span class="string">    like IDA Pro&#x27;s CFG, where calls to returning functions do not terminate basic blocks.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param networkx.DiGraph transition_graph: The transition graph.</span></span><br><span class="line"><span class="string">    :return: A converted super transition graph</span></span><br><span class="line"><span class="string">    :rtype networkx.DiGraph</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># make a copy of the graph</span></span><br><span class="line">    transition_graph = networkx.DiGraph(transition_graph)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># remove all edges that transitions to outside</span></span><br><span class="line">    <span class="keyword">for</span> src, dst, data <span class="keyword">in</span> <span class="built_in">list</span>(transition_graph.edges(data=<span class="literal">True</span>)):</span><br><span class="line">        <span class="keyword">if</span> data[<span class="string">&#x27;type&#x27;</span>] <span class="keyword">in</span> (<span class="string">&#x27;transition&#x27;</span>, <span class="string">&#x27;exception&#x27;</span>) <span class="keyword">and</span> data.get(<span class="string">&#x27;outside&#x27;</span>, <span class="literal">False</span>) <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            transition_graph.remove_edge(src, dst)</span><br><span class="line">        <span class="keyword">if</span> transition_graph.in_degree(dst) == <span class="number">0</span>:</span><br><span class="line">            transition_graph.remove_node(dst)</span><br><span class="line"></span><br><span class="line">    edges_to_shrink = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find all edges to remove in the super graph</span></span><br><span class="line">    <span class="keyword">for</span> src <span class="keyword">in</span> transition_graph.nodes():</span><br><span class="line">        edges = transition_graph[src]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># there are two types of edges we want to remove:</span></span><br><span class="line">        <span class="comment"># - call or fakerets, since we do not want blocks to break at calls</span></span><br><span class="line">        <span class="comment"># - boring jumps that directly transfer the control to the block immediately after the current block. this is</span></span><br><span class="line">        <span class="comment">#   usually caused by how VEX breaks down basic blocks, which happens very often in MIPS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(edges) == <span class="number">1</span> <span class="keyword">and</span> src.addr + src.size == <span class="built_in">next</span>(<span class="built_in">iter</span>(edges.keys())).addr:</span><br><span class="line">            dst = <span class="built_in">next</span>(<span class="built_in">iter</span>(edges.keys()))</span><br><span class="line">            dst_in_edges = transition_graph.in_edges(dst)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(dst_in_edges) == <span class="number">1</span>:</span><br><span class="line">                edges_to_shrink.add((src, dst))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(<span class="built_in">iter</span>(<span class="string">&#x27;type&#x27;</span> <span class="keyword">in</span> data <span class="keyword">and</span> data[<span class="string">&#x27;type&#x27;</span>] <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;fake_return&#x27;</span>, <span class="string">&#x27;call&#x27;</span>) <span class="keyword">for</span> data <span class="keyword">in</span> edges.values())):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> dst, data <span class="keyword">in</span> edges.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(dst, Function):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;type&#x27;</span> <span class="keyword">in</span> data <span class="keyword">and</span> data[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;fake_return&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">all</span>(<span class="built_in">iter</span>(<span class="string">&#x27;type&#x27;</span> <span class="keyword">in</span> data <span class="keyword">and</span> data[<span class="string">&#x27;type&#x27;</span>] <span class="keyword">in</span> (<span class="string">&#x27;fake_return&#x27;</span>, <span class="string">&#x27;return_from_call&#x27;</span>)</span><br><span class="line">                            <span class="keyword">for</span> _, _, data <span class="keyword">in</span> transition_graph.in_edges(dst, data=<span class="literal">True</span>))):</span><br><span class="line">                    edges_to_shrink.add((src, dst))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the super graph</span></span><br><span class="line">    super_graph = networkx.DiGraph()</span><br><span class="line"></span><br><span class="line">    supernodes_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function_nodes = <span class="built_in">set</span>()  <span class="comment"># it will be traversed after all other nodes are added into the supergraph</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> transition_graph.nodes():</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Function):</span><br><span class="line">            function_nodes.add(node)</span><br><span class="line">            <span class="comment"># don&#x27;t put functions into the supergraph</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        dests_and_data = transition_graph[node]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># make a super node</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">in</span> supernodes_map:</span><br><span class="line">            src_supernode = supernodes_map[node]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            src_supernode = SuperCFGNode.from_cfgnode(node)</span><br><span class="line">            supernodes_map[node] = src_supernode</span><br><span class="line">            <span class="comment"># insert it into the graph</span></span><br><span class="line">            super_graph.add_node(src_supernode)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dests_and_data:</span><br><span class="line">            <span class="comment"># might be an isolated node</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Take src_supernode off the graph since we might modify it</span></span><br><span class="line">        <span class="keyword">if</span> src_supernode <span class="keyword">in</span> super_graph:</span><br><span class="line">            existing_in_edges = <span class="built_in">list</span>(super_graph.in_edges(src_supernode, data=<span class="literal">True</span>))</span><br><span class="line">            existing_out_edges = <span class="built_in">list</span>(super_graph.out_edges(src_supernode, data=<span class="literal">True</span>))</span><br><span class="line">            super_graph.remove_node(src_supernode)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            existing_in_edges = [ ]</span><br><span class="line">            existing_out_edges = [ ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> dst, data <span class="keyword">in</span> dests_and_data.items():</span><br><span class="line"></span><br><span class="line">            edge = (node, dst)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> edge <span class="keyword">in</span> edges_to_shrink:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dst <span class="keyword">in</span> supernodes_map:</span><br><span class="line">                    dst_supernode = supernodes_map[dst]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dst_supernode = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">                src_supernode.insert_cfgnode(dst)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># update supernodes map</span></span><br><span class="line">                supernodes_map[dst] = src_supernode</span><br><span class="line"></span><br><span class="line">                <span class="comment"># merge the other supernode</span></span><br><span class="line">                <span class="keyword">if</span> dst_supernode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    src_supernode.merge(dst_supernode)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> src <span class="keyword">in</span> dst_supernode.cfg_nodes:</span><br><span class="line">                        supernodes_map[src] = src_supernode</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># link all out edges of dst_supernode to src_supernode</span></span><br><span class="line">                    <span class="keyword">for</span> dst_, data_ <span class="keyword">in</span> super_graph[dst_supernode].items():</span><br><span class="line">                        super_graph.add_edge(src_supernode, dst_, **data_)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># link all in edges of dst_supernode to src_supernode</span></span><br><span class="line">                    <span class="keyword">for</span> src_, _, data_ <span class="keyword">in</span> super_graph.in_edges(dst_supernode, data=<span class="literal">True</span>):</span><br><span class="line">                        super_graph.add_edge(src_, src_supernode, **data_)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> <span class="string">&#x27;type&#x27;</span> <span class="keyword">in</span> data_ <span class="keyword">and</span> data_[<span class="string">&#x27;type&#x27;</span>] <span class="keyword">in</span> (<span class="string">&#x27;transition&#x27;</span>, <span class="string">&#x27;exception&#x27;</span>):</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">not</span> (<span class="string">&#x27;ins_addr&#x27;</span> <span class="keyword">in</span> data_ <span class="keyword">and</span> <span class="string">&#x27;stmt_idx&#x27;</span> <span class="keyword">in</span> data_):</span><br><span class="line">                                <span class="comment"># this is a hack to work around the issue in Function.normalize() where ins_addr and</span></span><br><span class="line">                                <span class="comment"># stmt_idx weren&#x27;t properly set onto edges</span></span><br><span class="line">                                <span class="keyword">continue</span></span><br><span class="line">                            src_supernode.register_out_branch(data_[<span class="string">&#x27;ins_addr&#x27;</span>], data_[<span class="string">&#x27;stmt_idx&#x27;</span>], data_[<span class="string">&#x27;type&#x27;</span>],</span><br><span class="line">                                                              dst_supernode.addr</span><br><span class="line">                                                              )</span><br><span class="line"></span><br><span class="line">                    super_graph.remove_node(dst_supernode)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(dst, Function):</span><br><span class="line">                    <span class="comment"># skip all functions</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># make a super node</span></span><br><span class="line">                <span class="keyword">if</span> dst <span class="keyword">in</span> supernodes_map:</span><br><span class="line">                    dst_supernode = supernodes_map[dst]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dst_supernode = SuperCFGNode.from_cfgnode(dst)</span><br><span class="line">                    supernodes_map[dst] = dst_supernode</span><br><span class="line"></span><br><span class="line">                super_graph.add_edge(src_supernode, dst_supernode, **data)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;type&#x27;</span> <span class="keyword">in</span> data <span class="keyword">and</span> data[<span class="string">&#x27;type&#x27;</span>] <span class="keyword">in</span> (<span class="string">&#x27;transition&#x27;</span>, <span class="string">&#x27;exception&#x27;</span>):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="string">&#x27;ins_addr&#x27;</span> <span class="keyword">in</span> data <span class="keyword">and</span> <span class="string">&#x27;stmt_idx&#x27;</span> <span class="keyword">in</span> data):</span><br><span class="line">                        <span class="comment"># this is a hack to work around the issue in Function.normalize() where ins_addr and</span></span><br><span class="line">                        <span class="comment"># stmt_idx weren&#x27;t properly set onto edges</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    src_supernode.register_out_branch(data[<span class="string">&#x27;ins_addr&#x27;</span>], data[<span class="string">&#x27;stmt_idx&#x27;</span>], data[<span class="string">&#x27;type&#x27;</span>],</span><br><span class="line">                                                      dst_supernode.addr</span><br><span class="line">                                                      )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add back the node (in case there are no edges)</span></span><br><span class="line">        super_graph.add_node(src_supernode)</span><br><span class="line">        <span class="comment"># add back the old edges</span></span><br><span class="line">        <span class="keyword">for</span> src, _, data <span class="keyword">in</span> existing_in_edges:</span><br><span class="line">            super_graph.add_edge(src, src_supernode, **data)</span><br><span class="line">        <span class="keyword">for</span> _, dst, data <span class="keyword">in</span> existing_out_edges:</span><br><span class="line">            super_graph.add_edge(src_supernode, dst, **data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> function_nodes:</span><br><span class="line">        in_edges = transition_graph.in_edges(node, data=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> src, _, data <span class="keyword">in</span> in_edges:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (<span class="string">&#x27;ins_addr&#x27;</span> <span class="keyword">in</span> data <span class="keyword">and</span> <span class="string">&#x27;stmt_idx&#x27;</span> <span class="keyword">in</span> data):</span><br><span class="line">                <span class="comment"># this is a hack to work around the issue in Function.normalize() where ins_addr and</span></span><br><span class="line">                <span class="comment"># stmt_idx weren&#x27;t properly set onto edges</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            supernode = supernodes_map[src]</span><br><span class="line">            supernode.register_out_branch(data[<span class="string">&#x27;ins_addr&#x27;</span>], data[<span class="string">&#x27;stmt_idx&#x27;</span>], data[<span class="string">&#x27;type&#x27;</span>], node.addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> super_graph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutBranch</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ins_addr, stmt_idx, branch_type</span>):</span><br><span class="line">        self.ins_addr = ins_addr</span><br><span class="line">        self.stmt_idx = stmt_idx</span><br><span class="line">        self.<span class="built_in">type</span> = branch_type</span><br><span class="line"></span><br><span class="line">        self.targets = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.ins_addr <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&lt;OutBranch at None, type %s&gt;&quot;</span> % self.<span class="built_in">type</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;OutBranch at %#x, type %s&gt;&quot;</span> % (self.ins_addr, self.<span class="built_in">type</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_target</span>(<span class="params">self, addr</span>):</span><br><span class="line">        self.targets.add(addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Merge with the other OutBranch descriptor.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param OutBranch other: The other item to merge with.</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> self.ins_addr == other.ins_addr</span><br><span class="line">        <span class="keyword">assert</span> self.<span class="built_in">type</span> == other.<span class="built_in">type</span></span><br><span class="line"></span><br><span class="line">        o = self.copy()</span><br><span class="line">        o.targets |= other.targets</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> o</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">copy</span>(<span class="params">self</span>):</span><br><span class="line">        o = OutBranch(self.ins_addr, self.stmt_idx, self.<span class="built_in">type</span>)</span><br><span class="line">        o.targets = self.targets.copy()</span><br><span class="line">        <span class="keyword">return</span> o</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, OutBranch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.ins_addr == other.ins_addr <span class="keyword">and</span> \</span><br><span class="line">               self.stmt_idx == other.stmt_idx <span class="keyword">and</span> \</span><br><span class="line">               self.<span class="built_in">type</span> == other.<span class="built_in">type</span> <span class="keyword">and</span> \</span><br><span class="line">               self.targets == other.targets</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((self.ins_addr, self.stmt_idx, self.<span class="built_in">type</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperCFGNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, addr</span>):</span><br><span class="line">        self.addr = addr</span><br><span class="line"></span><br><span class="line">        self.cfg_nodes = [ ]</span><br><span class="line"></span><br><span class="line">        self.out_branches = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(node.size <span class="keyword">for</span> node <span class="keyword">in</span> self.cfg_nodes)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_cfgnode</span>(<span class="params">cls, cfg_node</span>):</span><br><span class="line">        s = cls(cfg_node.addr)</span><br><span class="line"></span><br><span class="line">        s.cfg_nodes.append(cfg_node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_cfgnode</span>(<span class="params">self, cfg_node</span>):</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> Make it binary search/insertion</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.cfg_nodes):</span><br><span class="line">            <span class="keyword">if</span> cfg_node.addr &lt; n.addr:</span><br><span class="line">                <span class="comment"># insert before n</span></span><br><span class="line">                self.cfg_nodes.insert(i, cfg_node)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> cfg_node.addr == n.addr:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.cfg_nodes.append(cfg_node)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># update addr</span></span><br><span class="line">        self.addr = self.cfg_nodes[<span class="number">0</span>].addr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register_out_branch</span>(<span class="params">self, ins_addr, stmt_idx, branch_type, target_addr</span>):</span><br><span class="line">        <span class="keyword">if</span> ins_addr <span class="keyword">not</span> <span class="keyword">in</span> self.out_branches <span class="keyword">or</span> stmt_idx <span class="keyword">not</span> <span class="keyword">in</span> self.out_branches[ins_addr]:</span><br><span class="line">            self.out_branches[ins_addr][stmt_idx] = OutBranch(ins_addr, stmt_idx, branch_type)</span><br><span class="line"></span><br><span class="line">        self.out_branches[ins_addr][stmt_idx].add_target(target_addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Merge another supernode into the current one.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param SuperCFGNode other: The supernode to merge with.</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> other.cfg_nodes:</span><br><span class="line">            self.insert_cfgnode(n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ins_addr, outs <span class="keyword">in</span> other.out_branches.items():</span><br><span class="line">            <span class="keyword">if</span> ins_addr <span class="keyword">in</span> self.out_branches:</span><br><span class="line">                <span class="keyword">for</span> stmt_idx, item <span class="keyword">in</span> outs.items():</span><br><span class="line">                    <span class="keyword">if</span> stmt_idx <span class="keyword">in</span> self.out_branches[ins_addr]:</span><br><span class="line">                        self.out_branches[ins_addr][stmt_idx].merge(item)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        self.out_branches[ins_addr][stmt_idx] = item</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                item = <span class="built_in">next</span>(<span class="built_in">iter</span>(outs.values()))</span><br><span class="line">                self.out_branches[ins_addr][item.stmt_idx] = item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;SuperCFGNode %#08x, %d blocks, %d out branches&gt;&quot;</span> % (self.addr, <span class="built_in">len</span>(self.cfg_nodes),</span><br><span class="line">                                                                     <span class="built_in">len</span>(self.out_branches)</span><br><span class="line">                                                                     )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((<span class="string">&#x27;supercfgnode&#x27;</span>, self.addr))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, SuperCFGNode):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.addr == other.addr</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>去混淆脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">st = <span class="number">0x0000000000400620</span> </span><br><span class="line">end = <span class="number">0x0000000000402144</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">next_instr</span>(<span class="params">addr</span>):</span><br><span class="line">    <span class="keyword">return</span> addr+idc.get_item_size(addr)		<span class="comment">#获取指令或数据长度，这个函数的作用就是去往下一条指令</span></span><br><span class="line">    </span><br><span class="line">addr = st</span><br><span class="line"><span class="keyword">while</span>(addr&lt;end):</span><br><span class="line">    <span class="built_in">next</span> = next_instr(addr)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;ds:dword_603054&quot;</span> <span class="keyword">in</span> GetDisasm(addr):	<span class="comment">#GetDisasm(addr)得到addr的反汇编语句</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            addr = <span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span> = next_instr(addr)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;jnz&quot;</span> <span class="keyword">in</span> GetDisasm(addr):</span><br><span class="line">                dest = idc.get_operand_value(addr, <span class="number">0</span>)		<span class="comment">#得到操作数，就是指令后的数</span></span><br><span class="line">                ida_bytes.patch_byte(addr, <span class="number">0xe9</span>)     <span class="comment">#0xe9 jmp后面的四个字节是偏移</span></span><br><span class="line">                ida_bytes.patch_byte(addr+<span class="number">5</span>, <span class="number">0x90</span>)   <span class="comment">#nop第五个字节</span></span><br><span class="line">                offset = dest - (addr + <span class="number">5</span>)  <span class="comment">#调整为正确的偏移地址 也就是相对偏移地址 - 当前指令后的地址</span></span><br><span class="line">                ida_bytes.patch_dword(addr + <span class="number">1</span>, offset) <span class="comment">#把地址赋值给jmp后</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;patch bcf: 0x%x&quot;</span>%addr)</span><br><span class="line">                addr = <span class="built_in">next</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        addr = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解密脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">secret = [<span class="number">0xBC8FF26D43536296</span>, <span class="number">0x520100780530EE16</span>, <span class="number">0x4DC0B5EA935F08EC</span>,</span><br><span class="line">          <span class="number">0x342B90AFD853F450</span>, <span class="number">0x8B250EBCAA2C3681</span>, <span class="number">0x55759F81A2C68AE4</span>]</span><br><span class="line">key = <span class="number">0xB0004B7679FA26B3</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生CRC32查表法所用的表</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> secret:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        sign = s &amp; <span class="number">1</span>                   <span class="comment">#判断首位正负</span></span><br><span class="line">        <span class="keyword">if</span> sign == <span class="number">1</span>:</span><br><span class="line">            s ^= key</span><br><span class="line">        s //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> sign == <span class="number">1</span>:</span><br><span class="line">            s |= <span class="number">0x8000000000000000</span>    <span class="comment"># 防止负值除2，溢出为正值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(s))                      <span class="comment"># 输出表</span></span><br><span class="line">    <span class="comment"># 计算CRC64</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="number">8</span>:</span><br><span class="line">        flag += <span class="built_in">chr</span>(s&amp;<span class="number">0xFF</span>)</span><br><span class="line">        s &gt;&gt;= <span class="number">8</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CTF题解——reverse</category>
      </categories>
  </entry>
  <entry>
    <title>《c++反汇编与逆向分析技术揭秘》速记1</title>
    <url>/2022/11/05/fast_sum1/</url>
    <content><![CDATA[<h2 id="基本类型表示"><a href="#基本类型表示" class="headerlink" title="基本类型表示"></a>基本类型表示</h2><ul>
<li><p>无符号整数：全部字节表示数字，只有正数</p>
</li>
<li><p>有符号整数：最高位表示正负</p>
</li>
<li><p>负数表示</p>
<ul>
<li><p>补码（0减去该数的绝对值）存放，补码 &#x3D; 反码 + 1，进位丢失</p>
</li>
<li><p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">--&gt; -<span class="number">3</span></span><br><span class="line">--&gt; <span class="number">0</span>减去该数的绝对值</span><br><span class="line">----&gt; <span class="number">0xFFFFFFFD</span> + <span class="number">3</span> = <span class="number">0</span>，最高位溢出 &gt;&gt; <span class="number">0xFFFFFFFD</span>表示-<span class="number">3</span></span><br><span class="line">--&gt; 补码 = 反码 + <span class="number">1</span></span><br><span class="line">----&gt; <span class="built_in">bin</span>(<span class="number">3</span>):<span class="number">11</span></span><br><span class="line">----&gt; <span class="built_in">bin</span>(<span class="number">3</span>)反码:<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1100</span></span><br><span class="line">----&gt; <span class="built_in">hex</span>(反码+<span class="number">1</span>):<span class="number">0xFFFFFFFD</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>浮点数</p>
<ul>
<li>定点实数存储：提前约定整数和小数长度，进行存放</li>
<li>浮点实数存储：开辟两个部分，一部分存指数域（小数点位置），一部分存数值大小（无小数点的整数）</li>
<li>编码方式（符号位-指数域-尾数域）<ul>
<li>float（size4，32位）：1-8-23</li>
<li>double（size8，64位）：1-11-52</li>
<li>因为指数域可能为负数，所以在指数存放时 + 0xf（ 127，1023），判别正负</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li>编码方式：unicode，ASCII···</li>
<li>存储<ul>
<li>线性存储，需要确定首尾地址</li>
<li>尾地址确定：<ol>
<li>开辟一部分空间存放长度len，首地址+len确定</li>
<li>利用结束符直接确定</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="main函数（语法规定用户入口）特点"><a href="#main函数（语法规定用户入口）特点" class="headerlink" title="main函数（语法规定用户入口）特点"></a>main函数（语法规定用户入口）特点</h2><blockquote>
<p>int __cdecl main(int argc, const char **argv, const char **envp)</p>
</blockquote>
<ul>
<li>main函数启动函数中唯一一个3参数函数：命令行参数个数、命令行参数信息、环境变量信息。</li>
<li>WinMain是唯一一个4参数函数</li>
<li>返回要调用exit()函数</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000401387           loc_401387:          </span><br><span class="line">.text:0000000000401387           mov     qword ptr [rax], 0</span><br><span class="line">.text:000000000040138E           mov     cs:argv, rbp</span><br><span class="line">.text:0000000000401395           call    __main</span><br><span class="line">.text:0000000000401395</span><br><span class="line">.text:000000000040139A           mov     rax, cs:_refptr___imp___initenv</span><br><span class="line">.text:00000000004013A1           mov     rdx, cs:envp</span><br><span class="line">.text:00000000004013A8           mov     ecx, cs:argc           ; argc</span><br><span class="line">.text:00000000004013AE           mov     rax, [rax]</span><br><span class="line">.text:00000000004013B1           mov     [rax], rdx</span><br><span class="line">.text:00000000004013B4           mov     r8, cs:envp            ; envp</span><br><span class="line">.text:00000000004013BB           mov     rdx, cs:argv           ; argv</span><br><span class="line">.text:00000000004013C2           call    main</span><br><span class="line">.text:00000000004013C2</span><br><span class="line">.text:00000000004013C7           mov     ecx, cs:managedapp</span><br><span class="line">.text:00000000004013CD           mov     cs:mainret, eax</span><br><span class="line">.text:00000000004013D3           test    ecx, ecx</span><br><span class="line">.text:00000000004013D5           jz      loc_40149E</span><br><span class="line">.text:00000000004013D5</span><br><span class="line">.text:00000000004013DB           mov     edx, cs:has_cctor</span><br><span class="line">.text:00000000004013E1           test    edx, edx</span><br><span class="line">.text:00000000004013E3           jnz     short loc_4013F0</span><br><span class="line">.text:00000000004013E3</span><br><span class="line">.text:00000000004013E5           call    _cexit                ;返回调用exit()函数</span><br></pre></td></tr></table></figure>

<h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><ul>
<li>无效语句，例如2+3；编译时自动剔除，不进行处理</li>
</ul>
]]></content>
      <categories>
        <category>CTF———知识点</category>
      </categories>
  </entry>
  <entry>
    <title>解题1</title>
    <url>/2022/10/16/Solve1/</url>
    <content><![CDATA[<h2 id="2022-x2F-11-x2F-09更新"><a href="#2022-x2F-11-x2F-09更新" class="headerlink" title="2022&#x2F;11&#x2F;09更新"></a>2022&#x2F;11&#x2F;09更新</h2><p>写一下一些奇葩题主体思路，不配图，不适合新手观看</p>
<h2 id="网鼎杯-2020-青龙组-jocker"><a href="#网鼎杯-2020-青龙组-jocker" class="headerlink" title="[网鼎杯 2020 青龙组]jocker"></a>[网鼎杯 2020 青龙组]jocker</h2><ol>
<li>exe文件，32位无壳，拖入IDA32</li>
<li>ctrl+f12定位主体函数，修改变量名提高可读性</li>
<li>F5反汇编发现提示栈错误，option调出栈指针，修改栈指针为0，重新F5</li>
<li>查看输入，24位字符串，主体：复制-&gt;加密-&gt;校对-&gt;encypt函数-&gt;final函数</li>
<li>发现wrong函数加密，omg函数校对，简单异或解密，提交错误，为障眼法（但是得到了正确的输入字符串）</li>
<li>wrong函数上方对输入的flag进行了复制，真正处理的是复制后的flag</li>
<li>找到相应的加密函数encypt，结果是动态加密函数，无法直接F5</li>
<li>exe拖入OD，找到调用加密函数地址，下断点，输入正确字符串运行</li>
<li>F7单步进入加密函数，ODdump脱壳，生成新文件</li>
<li>新文件拖入IDA，查看encypt函数，异或解密得到前19位flag</li>
<li>还剩最后5位，只剩final函数，未知加密，提示是隐藏，推断和之前加密方式相同，为异或加密</li>
<li>利用最后一位”}”推断出异或key，进行解密得到正确flag</li>
</ol>
<blockquote>
<p>核心：修改由于后续动态加密造成的栈指针错位，解密正确输入，OD动态加密脱壳</p>
</blockquote>
<h2 id="SWPU2019-EasiestRe"><a href="#SWPU2019-EasiestRe" class="headerlink" title="[SWPU2019]EasiestRe"></a>[SWPU2019]EasiestRe</h2><ol>
<li>拖入exeinfope，32位无壳，进IDA</li>
<li>ctrl+f找到main函数发现GetThreadContext、SetThreadContext等等函数，多线程没跑了，先放一边</li>
<li>ctrl+f12字符串查找flag找到主体函数(交叉引用)，修改变量名提高可读性</li>
<li>F5反编发现__debugbreak()，int3断点，可以准备改二进制了，继续查看还不止一个</li>
<li>重新看线程，是个父子线程保护，子线程加密，查看函数捕获重要长数组v16、v15</li>
<li>所以又是动态加密，返回__debugbreak()处tab看汇编，int3+nop的长度和v16对的上，那就把v16搬过去，改二进制，重新反编</li>
<li>观察主体函数：输入-&gt;加密-&gt;check-&gt;输出</li>
<li>进入加密，又有__debugbreak()，和上面一样的方式，用v15改二进制码，反编</li>
<li>进入check函数，tab查看汇编，408638地址处发现“cmp [ebp+var_20], 18h”校对指令</li>
<li>查看对应地址，找到校对字符串（即加密结果）</li>
<li>返回加密函数，分析，三次加密(异或–&gt;分段–&gt;移位)</li>
<li>逆写解密</li>
</ol>
<p>核心：双线程保护系统，int3断点(0xcc)，二进制修改</p>
<h2 id="WMCTF2020-easy-re"><a href="#WMCTF2020-easy-re" class="headerlink" title="[WMCTF2020]easy_re"></a>[WMCTF2020]easy_re</h2><ul>
<li>perl处理：一种解释语言，运行时解压，动调处理<ul>
<li>搜索script关键词，找到perl脚本调用处</li>
<li>再关键点下面设断点，F8运行到脚本执行完毕</li>
<li>下一个eax中可见原文</li>
</ul>
</li>
</ul>
<h2 id="BJDCTF2020-hamburger-competition"><a href="#BJDCTF2020-hamburger-competition" class="headerlink" title="[BJDCTF2020]hamburger competition"></a>[BJDCTF2020]hamburger competition</h2><ul>
<li><p>一个unity游戏逆向问题</p>
</li>
<li><p>工具：dnspy</p>
</li>
<li><p>核心代码一般路径：</p>
<blockquote>
<p>\TPH\TPH_Data\Managed\Assembly-CSharp.dll</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>CTF题解——reverse</category>
      </categories>
  </entry>
  <entry>
    <title>脚本函数积累</title>
    <url>/2022/10/12/shell/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来不想写的，后来发现自己脑子不太行根本记不住，查又不想查，所以慢慢积累吧，总有一天会用到的<br>我的设想是等未来达到一定数量以后再按python库整理，现在的话就这样散着</p>
<h2 id="sha1加密"><a href="#sha1加密" class="headerlink" title="sha1加密"></a>sha1加密</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">origin = <span class="built_in">input</span>()</span><br><span class="line">temp = hashlib.sha1(origin.encode())</span><br><span class="line"><span class="built_in">print</span>(temp.hexdigest())</span><br></pre></td></tr></table></figure>

<h2 id="求模乘逆元"><a href="#求模乘逆元" class="headerlink" title="求模乘逆元"></a>求模乘逆元</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># e*d mod φ(n) = 1</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">e = <span class="string">&#x27;e&#x27;</span></span><br><span class="line">phi = <span class="string">&#x27;φ(n)&#x27;</span></span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>

<h2 id="RSA共模攻击"><a href="#RSA共模攻击" class="headerlink" title="RSA共模攻击"></a>RSA共模攻击</h2><ul>
<li><p>使用同一个模数n</p>
</li>
<li><p>用两个不同的公钥e1、e2对同一段明文m进行加密得到两份密文c1、c2</p>
</li>
<li><p>解密公式：</p>
<blockquote>
<p>m &#x3D; (c1<sup>s1</sup> % n * c2<sup>s2</sup> % n) % n</p>
</blockquote>
</li>
<li><p>公式推导：</p>
<ul>
<li><p>由共模可推出  </p>
<ul>
<li>m<sup>e1</sup> % n &#x3D; c1   </li>
<li>m<sup>e2</sup> % n &#x3D; c2</li>
</ul>
</li>
<li><p>欧几里得扩展算法取s1、s2使得</p>
<ul>
<li>e1 * s1 + e2 * s2 &#x3D; 1</li>
</ul>
</li>
<li><p>m &#x3D; m<sup>(e1<em>s1+e2</em>s2)</sup> % n</p>
</li>
<li><p>m &#x3D; (c1<sup>s1</sup> % n * c2<sup>s2</sup> % n) % n</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span>  binascii</span><br><span class="line">c1 =</span><br><span class="line">n =</span><br><span class="line">e1 =</span><br><span class="line">c2 =</span><br><span class="line">e2 =</span><br><span class="line">r,s1,s2 = gmpy2.gcdext(e1, e2)    <span class="comment"># 扩展欧几里得算法</span></span><br><span class="line"><span class="comment"># 公式</span></span><br><span class="line">m = (gmpy2.powmod(c1,s1,n)*gmpy2.powmod(c2,s2,n)) % n   <span class="comment"># 计算明文m</span></span><br><span class="line">m = <span class="built_in">hex</span>(m)[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(m))</span><br></pre></td></tr></table></figure>





<h2 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 待加密信息</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;this is a md5 test.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建md5对象</span></span><br><span class="line">hl = hashlib.md5()</span><br><span class="line">hl.update(<span class="built_in">str</span>.encode(encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;MD5加密前为 ：&#x27;</span> + <span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;MD5加密后为 ：&#x27;</span> + hl.hexdigest())</span><br></pre></td></tr></table></figure>

<h2 id="XXTEA"><a href="#XXTEA" class="headerlink" title="XXTEA"></a>XXTEA</h2><ul>
<li>ISCTF2022 green_tea</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">参数描述:</span></span><br><span class="line"><span class="string">  DELTA: 神秘常数δ，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」</span></span><br><span class="line"><span class="string">      v: 需要加解密的数据，格式为32位的无符号整数组成的数组</span></span><br><span class="line"><span class="string">      n: n表示需要加密的32位无符号整数的个数（例：n为1时，只有v数组中的第一个元素被加密了），n不能大于v的长度</span></span><br><span class="line"><span class="string">      k: 密钥，格式为4个32位无符号整数组成的数组，即密钥长度为128位</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> c_uint32</span><br><span class="line"> </span><br><span class="line">DELTA = <span class="number">0x9E3779B9</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">v, n, k</span>):</span><br><span class="line">    rounds = <span class="number">6</span> + <span class="built_in">int</span>(<span class="number">52</span> / n)</span><br><span class="line">    <span class="built_in">sum</span> = c_uint32(<span class="number">0</span>)</span><br><span class="line">    z = v[n - <span class="number">1</span>].value</span><br><span class="line">    <span class="keyword">while</span> rounds &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">sum</span>.value += DELTA</span><br><span class="line">        e = (<span class="built_in">sum</span>.value &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; n - <span class="number">1</span>:</span><br><span class="line">            y = v[p + <span class="number">1</span>].value</span><br><span class="line">            v[p].value += (((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>)) ^ ((<span class="built_in">sum</span>.value ^ y) + (k[(p &amp; <span class="number">3</span>) ^ e] ^ z)))</span><br><span class="line">            z = v[p].value</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        y = v[<span class="number">0</span>].value</span><br><span class="line">        v[n - <span class="number">1</span>].value += (((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>)) ^ ((<span class="built_in">sum</span>.value ^ y) + (k[(p &amp; <span class="number">3</span>) ^ e] ^ z)))</span><br><span class="line">        z = v[n - <span class="number">1</span>].value</span><br><span class="line">        rounds -= <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">v, n, k</span>):</span><br><span class="line">    rounds = <span class="number">6</span> + <span class="built_in">int</span>(<span class="number">52</span> / n)</span><br><span class="line">    <span class="built_in">sum</span> = c_uint32(rounds * DELTA)</span><br><span class="line">    y = v[<span class="number">0</span>].value</span><br><span class="line">    <span class="keyword">while</span> rounds &gt; <span class="number">0</span>:</span><br><span class="line">        e = (<span class="built_in">sum</span>.value &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span></span><br><span class="line">        p = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p &gt; <span class="number">0</span>:</span><br><span class="line">            z = v[p - <span class="number">1</span>].value</span><br><span class="line">            v[p].value -= (((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>)) ^ ((<span class="built_in">sum</span>.value ^ y) + (k[(p &amp; <span class="number">3</span>) ^ e] ^ z)))</span><br><span class="line">            y = v[p].value</span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">        z = v[n - <span class="number">1</span>].value</span><br><span class="line">        v[<span class="number">0</span>].value -= (((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>)) ^ ((<span class="built_in">sum</span>.value ^ y) + (k[(p &amp; <span class="number">3</span>) ^ e] ^ z)))</span><br><span class="line">        y = v[<span class="number">0</span>].value</span><br><span class="line">        <span class="built_in">sum</span>.value -= DELTA</span><br><span class="line">        rounds -= <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    k = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    v = [c_uint32(<span class="number">1</span>), c_uint32(<span class="number">2</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;plain: 1 2&#x27;</span>)</span><br><span class="line">    encrypt(v, <span class="built_in">len</span>(v), k)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;encrypted: %X %X&#x27;</span> % (v[<span class="number">0</span>].value, v[<span class="number">1</span>].value))</span><br><span class="line">    decrypt(v, <span class="built_in">len</span>(v), k)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;decrypted: %X %X&#x27;</span> % (v[<span class="number">0</span>].value, v[<span class="number">1</span>].value))</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「koxb」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/koxb/article/details/<span class="number">120088234</span></span><br></pre></td></tr></table></figure>

<h2 id="参数注入"><a href="#参数注入" class="headerlink" title="参数注入"></a>参数注入</h2><ul>
<li>hackgame2022 flag自动机</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    HWND target = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取窗口句柄</span></span><br><span class="line">    target = <span class="built_in">FindWindowW</span>(<span class="string">L&quot;flag 自动机&quot;</span>, <span class="string">L&quot;flag 自动机&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x&quot;</span>, target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="built_in">PostMessageW</span>(target, <span class="number">0x111</span>, <span class="number">3</span>, <span class="number">114514</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CRC32"><a href="#CRC32" class="headerlink" title="CRC32"></a>CRC32</h2><ul>
<li>RoarCTF2019 polyre</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">secret = [<span class="number">0xBC8FF26D43536296</span>, <span class="number">0x520100780530EE16</span>, <span class="number">0x4DC0B5EA935F08EC</span>,</span><br><span class="line">          <span class="number">0x342B90AFD853F450</span>, <span class="number">0x8B250EBCAA2C3681</span>, <span class="number">0x55759F81A2C68AE4</span>]</span><br><span class="line">key = <span class="number">0xB0004B7679FA26B3</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生CRC32查表法所用的表</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> secret:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        sign = s &amp; <span class="number">1</span>                   <span class="comment">#判断首位正负</span></span><br><span class="line">        <span class="keyword">if</span> sign == <span class="number">1</span>:</span><br><span class="line">            s ^= key</span><br><span class="line">        s //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> sign == <span class="number">1</span>:</span><br><span class="line">            s |= <span class="number">0x8000000000000000</span>    <span class="comment"># 防止负值除2，溢出为正值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(s))                      <span class="comment"># 输出表</span></span><br><span class="line">    <span class="comment"># 计算CRC64</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="number">8</span>:</span><br><span class="line">        flag += <span class="built_in">chr</span>(s&amp;<span class="number">0xFF</span>)</span><br><span class="line">        s &gt;&gt;= <span class="number">8</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF———知识点</category>
      </categories>
  </entry>
  <entry>
    <title>《逆向工程核心原理》总结3</title>
    <url>/2022/10/08/Summary3/</url>
    <content><![CDATA[<h2 id="DLL文件"><a href="#DLL文件" class="headerlink" title="DLL文件"></a>DLL文件</h2><ul>
<li>（Dynamic Link Library）动态链接库</li>
<li>目的：解决在多进程时一个系统API可能会被多次调用，多次加载到内存造成空间浪费的问题</li>
<li>描述：<ul>
<li>库封装，单独组成DLL文件</li>
<li>内存映射技术，实现多进程共享同一个文件</li>
<li>更新库时替换对应DLL文件</li>
</ul>
</li>
<li>加载方式：<ul>
<li>显式链接：使用时加载，用完后释放内存</li>
<li>隐式链接：加载程序时将DLL全部加载，程序终止后释放内存</li>
</ul>
</li>
</ul>
<h2 id="节区删除"><a href="#节区删除" class="headerlink" title="节区删除"></a>节区删除</h2><ol>
<li>删除节区头，PEview中查看节区头起始地址及长度，在hex编辑器中将该区域用0覆盖</li>
<li>删除节区，查看节区起始偏移及长度，hex编辑器中删除</li>
<li>修改IMAGE_FILE_HEADER[Number Of Sections -&#x3D; 1]</li>
<li>修改IMAGE_OPTIONAL_HEADER[Size Of Image减少对应长度]</li>
</ol>
]]></content>
      <categories>
        <category>CTF———知识点</category>
      </categories>
  </entry>
  <entry>
    <title>《逆向工程核心原理》总结2</title>
    <url>/2022/10/06/Summary2/</url>
    <content><![CDATA[<h1 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h1><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><table>
<thead>
<tr>
<th>种类</th>
<th>主扩展名</th>
</tr>
</thead>
<tbody><tr>
<td>可执行系列</td>
<td>EXE，SCR</td>
</tr>
<tr>
<td>库系列</td>
<td>DLL，OCX，CPL，DRV</td>
</tr>
<tr>
<td>驱动程序系列</td>
<td>SYS，VXD</td>
</tr>
<tr>
<td>对象文件系列</td>
<td>OBJ</td>
</tr>
</tbody></table>
<h2 id="零碎点"><a href="#零碎点" class="headerlink" title="零碎点"></a>零碎点</h2><ol>
<li>PE文件分PE头与PE体</li>
<li>PE头由各种结构体构成，说明了文件大小、执行地址等等信息，PE体分多个节区，如代码段、数据段、资源段等。</li>
<li>PE文件在内存中和在磁盘中大小不同</li>
<li>RVA(相对虚拟地址)  VA(虚拟内存绝对地址)  RAW(文件偏移)</li>
</ol>
<h2 id="PE头分解"><a href="#PE头分解" class="headerlink" title="PE头分解"></a>PE头分解</h2><h3 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h3><p>核心参数：</p>
<ul>
<li>e_magic:DOS签名，“MZ”（DOS可执行文件设计者）</li>
<li>e_lfanew:指示NT头的偏移</li>
</ul>
<h3 id="DOS存根"><a href="#DOS存根" class="headerlink" title="DOS存根"></a>DOS存根</h3><p>一个可忽略项，可理解为DOS下执行的数据</p>
<blockquote>
<p>例如notepad.exe中的提示语:This program cannot be run in DOS mode</p>
</blockquote>
<h3 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_NT_HEADERS &#123;</span><br><span class="line">    DWORD Signature;                             //签名“PE”</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;                //文件头</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;      //可选头</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>
<h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_FILE_HEADER &#123;</span><br><span class="line">    WORD    Machine;                  //机器码（每种CPU都有各自的固定值，如intel x86的14C）</span><br><span class="line">    WORD    NumberOfSections;         //节区数量</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;     //指示可选头的大小</span><br><span class="line">    WORD    Characteristics;          //标识文件属性（是否为DLL等等）</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER</span><br></pre></td></tr></table></figure>
<h4 id="可选头-直接把64位的搬过来了"><a href="#可选头-直接把64位的搬过来了" class="headerlink" title="可选头(直接把64位的搬过来了)"></a>可选头(直接把64位的搬过来了)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER64 &#123;</span><br><span class="line">    WORD        Magic;                       //32-10B， 64-20B</span><br><span class="line">    BYTE        MajorLinkerVersion;          </span><br><span class="line">    BYTE        MinorLinkerVersion;</span><br><span class="line">    DWORD       SizeOfCode;</span><br><span class="line">    DWORD       SizeOfInitializedData;</span><br><span class="line">    DWORD       SizeOfUninitializedData;</span><br><span class="line">    DWORD       AddressOfEntryPoint;         //PE的RVA值，指出代码起始位置</span><br><span class="line">    DWORD       BaseOfCode;</span><br><span class="line">    ULONGLONG   ImageBase;                   //基准，VA = RVA + ImageBase</span><br><span class="line">    DWORD       SectionAlignment;            //节区内存最小单位</span><br><span class="line">    DWORD       FileAlignment;               //节区磁盘最小单位</span><br><span class="line">    WORD        MajorOperatingSystemVersion;</span><br><span class="line">    WORD        MinorOperatingSystemVersion;</span><br><span class="line">    WORD        MajorImageVersion;</span><br><span class="line">    WORD        MinorImageVersion;</span><br><span class="line">    WORD        MajorSubsystemVersion;</span><br><span class="line">    WORD        MinorSubsystemVersion;</span><br><span class="line">    DWORD       Win32VersionValue;</span><br><span class="line">    DWORD       SizeOfImage;                 //指定在虚拟内存中所占空间大小</span><br><span class="line">    DWORD       SizeOfHeaders;               //PE头大小（第一节区所在位置与该值距文件开始偏移量相同）</span><br><span class="line">    DWORD       CheckSum;</span><br><span class="line">    WORD        Subsystem;                   //区分文件</span><br><span class="line">                                              1 Driver文件（系统驱动）</span><br><span class="line">                                              2 GUI文件（窗口应用程序）</span><br><span class="line">                                              3 CUI文件（控制台应用程序）</span><br><span class="line">    WORD        DllCharacteristics;</span><br><span class="line">    ULONGLONG   SizeOfStackReserve;</span><br><span class="line">    ULONGLONG   SizeOfStackCommit;</span><br><span class="line">    ULONGLONG   SizeOfHeapReserve;</span><br><span class="line">    ULONGLONG   SizeOfHeapCommit;</span><br><span class="line">    DWORD       LoaderFlags;</span><br><span class="line">    DWORD       NumberOfRvaAndSizes;         //</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>
<h3 id="节区头"><a href="#节区头" class="headerlink" title="节区头"></a>节区头</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table>
<thead>
<tr>
<th>类别</th>
<th>访问权限</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>执行，读取权限</td>
</tr>
<tr>
<td>data</td>
<td>非执行，读写权限</td>
</tr>
<tr>
<td>resource</td>
<td>非执行，读取权限</td>
</tr>
</tbody></table>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define IMAGE_SIZEOF_SHORT_NAME              8</span></span><br><span class="line"></span><br><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    union &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;            //内存中节区大小</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;                 //内存中节区起始地址（RVA）</span><br><span class="line">    DWORD   SizeOfRawData;                  //磁盘中节区大小</span><br><span class="line">    DWORD   PointerToRawData;               //磁盘中节区起始地址</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;                //节区属性</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>
<h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><ul>
<li>RAW &#x3D; RVA - (VA)VirtualAddress + PointerToRawData</li>
</ul>
<h1 id="附表："><a href="#附表：" class="headerlink" title="附表："></a>附表：</h1><h2 id="DataDirectory结构体数组-64-01239为重点"><a href="#DataDirectory结构体数组-64-01239为重点" class="headerlink" title="DataDirectory结构体数组(64)[01239为重点]"></a>DataDirectory结构体数组(64)[01239为重点]</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory</span></span><br><span class="line">        IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors</span></span><br><span class="line"><span class="comment">#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor</span></span><br></pre></td></tr></table></figure>
<h2 id="Machine值"><a href="#Machine值" class="headerlink" title="Machine值"></a>Machine值</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_UNKNOWN           0</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_I386              0x014c  // Intel 386.</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_R3000             0x0162  // MIPS little-endian, 0x160 big-endian</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_R4000             0x0166  // MIPS little-endian</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_R10000            0x0168  // MIPS little-endian</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  // MIPS little-endian WCE v2</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_ALPHA             0x0184  // Alpha_AXP</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_SH3               0x01a2  // SH3 little-endian</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_SH3DSP            0x01a3</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_SH3E              0x01a4  // SH3E little-endian</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_SH4               0x01a6  // SH4 little-endian</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_SH5               0x01a8  // SH5</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_ARM               0x01c0  // ARM Little-Endian</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_THUMB             0x01c2</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_AM33              0x01d3</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_POWERPC           0x01F0  // IBM PowerPC Little-Endian</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_POWERPCFP         0x01f1</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_IA64              0x0200  // Intel 64</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_MIPS16            0x0266  // MIPS</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_ALPHA64           0x0284  // ALPHA64</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_MIPSFPU           0x0366  // MIPS</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  // MIPS</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_TRICORE           0x0520  // Infineon</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_CEF               0x0CEF</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_EBC               0x0EBC  // EFI Byte Code</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_AMD64             0x8664  // AMD64 (K8)</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_M32R              0x9041  // M32R little-endian</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_MACHINE_CEE               0xC0EE</span></span><br></pre></td></tr></table></figure>
<h2 id="Characteristics值"><a href="#Characteristics值" class="headerlink" title="Characteristics值"></a>Characteristics值</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  // Agressively trim working set</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  // App can handle &gt;2gb addresses</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  // If Image is on removable media, copy and run from the swap file.</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  // If Image is on Net, copy and run from the swap file.</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_SYSTEM                    0x1000  // System File.</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  // File should only be run on a UP machine</span></span><br><span class="line"><span class="comment">#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF———知识点</category>
      </categories>
  </entry>
  <entry>
    <title>《逆向工程核心原理》总结1</title>
    <url>/2022/10/05/Summary1/</url>
    <content><![CDATA[<h2 id="常见寄存器"><a href="#常见寄存器" class="headerlink" title="常见寄存器"></a>常见寄存器</h2><ul>
<li>通用寄存器<ul>
<li>EAX：（针对操作数和结果数据的）累加器</li>
<li>EBX：（DS段的数据指针）基址寄存器</li>
<li>ECX：（字符串和循环操作的）计数器</li>
<li>EDX：（I&#x2F;O指针）数据寄存器</li>
<li>ESI：（字符串操作源指针）源变址寄存器</li>
<li>EDI：（字符串操作目标指针）目的变址寄存器</li>
<li>EBP：（SS段中栈内数据指针）扩展基址指针寄存器[栈帧寄存器][栈底指针寄存器]</li>
<li>ESP：（SS段中栈指针）栈指针寄存器[指向栈顶]</li>
</ul>
</li>
<li>段寄存器<ul>
<li>CS：代码段寄存器</li>
<li>SS：栈段寄存器</li>
<li>DS：数据段寄存器</li>
<li>FS：数据段寄存器</li>
<li>ES：附加数据寄存器</li>
<li>GS：数据段寄存器</li>
</ul>
</li>
<li>程序状态与控制寄存器<ul>
<li>EFLAGS：标志寄存器，32个位元的01控制<ul>
<li>ZF(零标志器，运算结果为0时置1)  </li>
<li>CF(进位标志，运算结果向最高位以上进位时置1)  </li>
<li>OF(溢出标志) </li>
<li>AF(辅助进位标志，运算结果在第3位的时候置1)</li>
<li>SF(符号标志，有符号整型的符号位为1时置1)</li>
</ul>
</li>
</ul>
</li>
<li>指令指针寄存器<ul>
<li>EIP：保存CPU要执行的指令地址</li>
</ul>
</li>
</ul>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><ul>
<li>栈特点：FILO（first in last out）</li>
<li>在调用函数的时候需要将参数压入栈中，栈顶地址发生改变，而使用结束又需要将参数弹出，将栈恢复到被调用前的状态，为了便于管理，于是出现了栈帧。<ul>
<li>官方解释：利用EBP寄存器访问栈内局部变量、参数、函数返回地址的手段。</li>
<li>具体操作：在调用函数之前，将ESP中的栈顶地址存入EBP中，将该地址作为基准点。然后调用函数，ESP寄存器正常进行，其间可通过EBP去控制访问变量参数等等，在调用结束后，再将EBP中的基准点地址给到ESP，将栈的状态恢复到函数调用前</li>
<li>代码流程：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH EBP          ;函数开始</span><br><span class="line">MOV  EBP,ESP      ;将栈顶地址存入EBP中</span><br><span class="line"></span><br><span class="line">....              ;函数执行，期间EBP地址不变</span><br><span class="line"></span><br><span class="line">MOV  ESP,EBP      ;基准点地址给到ESP</span><br><span class="line">POP EBP           ;栈状态恢复，弹出EBP</span><br><span class="line">RETN              ;函数结束</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>(Calling Convention)</p>
<ul>
<li>三种方式(cdcel, stdcall, fastcall)<ul>
<li>cdcel<br>主要运用于c语言，由调用者负责清理栈<blockquote>
<p>函数调用结束后通过移动ESP，恢复到调用前的栈状态</p>
</blockquote>
</li>
<li>stdcall<br>主要运用于Win32 API，由被调用者清理栈<blockquote>
<p>在被调用函数的结尾通过RETN语句移动ESP到原位置</p>
</blockquote>
</li>
<li>fastcall<blockquote>
<p>使用寄存器去传递函数的部分参数，实现快速调用</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CTF———知识点</category>
      </categories>
  </entry>
  <entry>
    <title>APK反编</title>
    <url>/2022/09/18/APK/</url>
    <content><![CDATA[<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ol>
<li><p>修改apk文件后缀为zip，解压</p>
</li>
<li><p>将反编的dex文件复制到dex2jar工具目录下</p>
</li>
<li><p>使用命令生成jar文件</p>
<blockquote>
<p>d2j-dex2jar.bat document_name.dex</p>
</blockquote>
<p>如果出现下列报错(版本号不匹配):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">com.googlecode.d2j.DexException: not support version.</span><br><span class="line">     at com.googlecode.d2j.reader.DexFileReader.&lt;init&gt;(DexFileReader.java:151)</span><br><span class="line">     at com.googlecode.d2j.reader.DexFileReader.&lt;init&gt;(DexFileReader.java:211)</span><br><span class="line">     at com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:104)</span><br><span class="line">     at com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)</span><br><span class="line">     at com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)</span><br></pre></td></tr></table></figure>
<p>用文本编辑软件打开dex文件，将文件头改为035或者036</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dex</span><br><span class="line">037 9!Q&lt;€颧€?滣^氶wl?  p   x</span><br></pre></td></tr></table></figure>
<p>正常情况应该是这样的(没有任何多余)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E:\SoftWarePackage\Jd-GUI+dex2\dex2jar-2.0&gt;d2j-dex2jar.bat classes3.dex</span><br><span class="line"> dex2jar classes3.dex -&gt; .\classes3-dex2jar.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>用jd-guijar反编译jar文件，命令是这个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar jd-gui-1.5.0.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>其实就是执行jar文件而已，可以直接写bat桌面一键打开</li>
</ul>
</li>
<li><p>收工</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CTF———知识点</category>
      </categories>
      <tags>
        <tag>反汇编</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>OD使用</title>
    <url>/2022/09/15/OD/</url>
    <content><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>F2</td>
<td>断点</td>
</tr>
<tr>
<td>F4</td>
<td>让程序执行到光标处</td>
</tr>
<tr>
<td>F7</td>
<td>单步步入</td>
</tr>
<tr>
<td>F8</td>
<td>单步步过</td>
</tr>
<tr>
<td>F9</td>
<td>让程序执行到断点处</td>
</tr>
<tr>
<td>Ctrl+F2</td>
<td>重载程序</td>
</tr>
<tr>
<td>Ctrl+G</td>
<td>快速定位</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CTF——工具</category>
      </categories>
      <tags>
        <tag>反汇编</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>解方程用的牛马z3</title>
    <url>/2022/09/14/z3/</url>
    <content><![CDATA[<p>鉴于某些方程不是人解的，所以就用z3了….</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><blockquote>
<p>直接搞到网盘上用链接吧：<br>链接：(<a href="https://pan.baidu.com/s/1gni_eYUC-Y_dQVogJh9QyA?pwd=1234">https://pan.baidu.com/s/1gni_eYUC-Y_dQVogJh9QyA?pwd=1234</a>)<br>提取码：1234</p>
</blockquote>
<ol>
<li>下载解压</li>
<li>将文件中bin目录配置到系统变量path中</li>
<li>新建PYTHONPATH系统变量，路径为bin&#x2F;python目录</li>
</ol>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ol>
<li>打开黑框框</li>
</ol>
<blockquote>
<p>cmd到bin&#x2F;python的目录</p>
</blockquote>
<p>or</p>
<blockquote>
<p>在bin&#x2F;python目录下shift右键powershell</p>
</blockquote>
<ol start="2">
<li><p>输入python</p>
</li>
<li><p>把代码输进去回车就完了</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li><p>先看官方示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line">x = Real(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">y = Real(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(x + y &gt; 5, x &gt; 1, y &gt; 1)</span><br><span class="line"><span class="built_in">print</span>(s.check())</span><br><span class="line"><span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure>
</li>
<li><p>简单说一下</p>
</li>
</ul>
<ol>
<li>导包z3</li>
<li>a &#x3D; Real(b), a为方程中的未知数，b为输出时候用来表示a的变量</li>
<li>Solver()，简言之：解决函数，方程接收器</li>
<li>add()，括号里塞方程就行，用“,”隔开，或者你多用几个add()也行</li>
<li>后面俩不用动了，就那样</li>
<li>回车出结果</li>
</ol>
]]></content>
      <categories>
        <category>CTF——工具</category>
      </categories>
  </entry>
  <entry>
    <title>IDA快捷操作</title>
    <url>/2022/09/08/IDA/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>F5</td>
<td>反汇编</td>
</tr>
<tr>
<td>函数列表Ctrl+F</td>
<td>搜索函数</td>
</tr>
<tr>
<td>X</td>
<td>交叉引用</td>
</tr>
<tr>
<td>G</td>
<td>跳转到指定地址</td>
</tr>
<tr>
<td>Shift+F12</td>
<td>字符串列表</td>
</tr>
<tr>
<td>Alt+T</td>
<td>按指令查找</td>
</tr>
<tr>
<td>N</td>
<td>重命名(函数名等)</td>
</tr>
<tr>
<td>Ctrl+Z</td>
<td>操作撤销</td>
</tr>
<tr>
<td>D</td>
<td>将字符串等元素转为数据</td>
</tr>
<tr>
<td>A</td>
<td>将数据转变为字符串</td>
</tr>
<tr>
<td>C</td>
<td>将数据转变为汇编代码</td>
</tr>
<tr>
<td>U</td>
<td>将字符串转变为原始数据</td>
</tr>
<tr>
<td>Shift+E</td>
<td>导出数据</td>
</tr>
<tr>
<td>Shift+F2</td>
<td>脚本嵌入</td>
</tr>
<tr>
<td>;</td>
<td>添加注释(所有交叉参考处均显示)</td>
</tr>
<tr>
<td>:</td>
<td>添加注释(仅在此处显示)</td>
</tr>
<tr>
<td>Esc</td>
<td>后退一步</td>
</tr>
<tr>
<td>Ctrl+Enter</td>
<td>前进一步</td>
</tr>
<tr>
<td>Alt+M</td>
<td>标记当前位置</td>
</tr>
<tr>
<td>Ctrl+M</td>
<td>跳转到标记位置</td>
</tr>
<tr>
<td>P</td>
<td>创建函数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CTF——工具</category>
      </categories>
      <tags>
        <tag>反汇编</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>幂数加密</title>
    <url>/2022/09/07/index/</url>
    <content><![CDATA[<h3 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h3><ul>
<li>由于每一个数都可以变成形式为”2<sup>a</sup>+2<sup>b</sup>+2<sup>c</sup>….”的表达式<br>所以我们用对应”abc…”数字串来代表这个数</li>
<li>例如<br>5 &#x3D; 2<sup>0</sup>+2<sup>2</sup>，即可表示为02<br>19 &#x3D; 2<sup>0</sup>+2<sup>1</sup>+2<sup>4</sup>，即014</li>
</ul>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>8842101220480224404014224202480122</p>
</blockquote>
<ul>
<li>是8位大写字母</li>
<li>采用幂数加密</li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul>
<li><p>联想8位字母和8个0的字符串，猜测<font color="#f18583">以0为分隔符</font><br>拆分后可以得到：</p>
<blockquote>
<p>88421 122 48 2244 4 142242 248 122</p>
</blockquote>
</li>
<li><p>观察发现每个数字都是2的倍数，推断单个数字表示的就是”2<sup>a</sup>“，所以将每一段数字直接求和</p>
</li>
<li><p>上脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	string s = <span class="string">&quot;88421 122 48 2244 4 142242 248 122 &quot;</span>; </span><br><span class="line">	int <span class="built_in">sum</span> = 0;</span><br><span class="line">	<span class="keyword">for</span>(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">			cout &lt;&lt;<span class="string">char(sum+&#x27;A&#x27;-1);</span></span><br><span class="line"><span class="string">			sum = 0;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		else&#123;</span></span><br><span class="line"><span class="string">			sum += (s[i]-&#x27;0&#x27;);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>得到flag：</p>
<blockquote>
<p>cyberpace{WELLDONE}</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>CTF题解——crypto</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>python-trade</title>
    <url>/2022/09/07/python-trade/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>此处无法显示。。。。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul>
<li>拿到的是一个pyc文件，那第一步必定是反编回去看源码<br>利用uncompyle6反编之后得到</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">base64</span></span><br><span class="line"></span><br><span class="line">def encode(message):</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">        x = ord(i) ^ 32</span><br><span class="line">        x = x + 16</span><br><span class="line">        s += chr(x)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> base64.b64encode(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">correct = <span class="string">&#x27;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Input flag:&#x27;</span>)</span><br><span class="line">flag = input()</span><br><span class="line"><span class="keyword">if</span> encode(flag) == correct:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;correct&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;wrong&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>源码倒是简单，flag经过一个<font color="#f18583">encode()函数</font>加密之后变成了</p>
<blockquote>
<p>XlNkVmtUI1MgXWBZXCFeKY+AaXNt</p>
</blockquote>
</li>
<li><p>直接写脚本：<br>按encode()逆一下就行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">base64</span></span><br><span class="line">a = <span class="string">&#x27;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#x27;</span></span><br><span class="line">a = base64.b64decode(a)</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    x = (i-16)^32</span><br><span class="line">    s += chr(x)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到flag：</p>
<blockquote>
<p>nctf{d3c0mpil1n9_PyC}</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>这绝对是我最近遇到的最舒适的题</p>
</blockquote>
]]></content>
      <categories>
        <category>CTF题解——reverse</category>
      </categories>
      <tags>
        <tag>base64</tag>
        <tag>pyc反编</tag>
      </tags>
  </entry>
  <entry>
    <title>pyc文件反编</title>
    <url>/2022/09/07/Re_pyc/</url>
    <content><![CDATA[<h2 id="2022-x2F-10-x2F-25-重写"><a href="#2022-x2F-10-x2F-25-重写" class="headerlink" title="2022&#x2F;10&#x2F;25 重写"></a>2022&#x2F;10&#x2F;25 重写</h2><ul>
<li><p>加一个内容：exe到pyc的转化</p>
<ul>
<li>可操作exe的识别（用python编译生成的exe文件一般来讲会比较大）</li>
<li>具体处理（利用脚本完成）</li>
</ul>
</li>
<li><p>py脚本（pyinstxtractor）</p>
<p>（<a href="https://gitcode.net/mirrors/extremecoders-re/pyinstxtractor?utm_source=csdn_github_accelerator">mirrors &#x2F; extremecoders-re &#x2F; pyinstxtractor · GitCode</a>）</p>
</li>
<li><p>使用</p>
<ul>
<li><p>建议官方文档readme.md</p>
</li>
<li><p>比较常见的操作就是将要转化的exe程序复制到脚本文件目录下，执行命令</p>
<blockquote>
<p>python pyinstxtractor.py test.exe</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="pyc文件反编"><a href="#pyc文件反编" class="headerlink" title="pyc文件反编"></a>pyc文件反编</h3><p>py生成的中间文件</p>
<blockquote>
<p>先省略无数字，需要深入了解底层再说</p>
</blockquote>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ul>
<li><p>借用外部资源，安装uncompyle6</p>
<blockquote>
<p>pip install uncompyle</p>
</blockquote>
</li>
<li><p>使用</p>
<blockquote>
<p>uncompyle6 name.pyc &gt; name.py</p>
</blockquote>
</li>
<li><p>或者直接用网上的在线反编译：<br>(<a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a>)</p>
</li>
</ul>
<blockquote>
<p>因为比较bug的一件事情是：<br>我遇到了某pyc文件用uncompyle6无法反编的情况，目前推测应该是版本不对的问题<br>后续再研究研究</p>
</blockquote>
<h3 id="涉及题目"><a href="#涉及题目" class="headerlink" title="涉及题目"></a>涉及题目</h3><ul>
<li>python-trade</li>
</ul>
]]></content>
      <categories>
        <category>CTF——工具</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>fanfie</title>
    <url>/2022/09/06/fanfie/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>来源：BITSCTF2017</p>
<blockquote>
<p>Brute and get the base 32 format of flag.<br>encrypted.txt: MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI</p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目是一如既往的简洁<br>首先题目告诉我们有<font color="#f18583">base32编码</font><br>同时由题目来源可知flag格式为<font color="#f18583">BITSCTF{}</font></p>
<p>所以<br>对”<b>BITSCTF{</b>“进行base32编码得到”<b>IJEVIU2DKRDHW&#x3D;&#x3D;&#x3D;</b>“</p>
<p>接下来就是玄学猜想:<br>编码后变长了，或许刚好和题目给的密文等长吧，考虑单表加密<br>I变M，J变Z，E变Y，很明显没直接的映射规律，考虑<a href="http://woodenmandu.cn/2022/09/06/Affine/">仿射密码</a></p>
<p>下一步计算a，b</p>
<blockquote>
<p>别忘记这是base32，加密函数为E(x) &#x3D; (ax+b)%32</p>
</blockquote>
<ul>
<li>小算一下，拿两组数据：<blockquote>
<p>8(I)–&gt;12(M)<br>9(J)–&gt;25(Z)</p>
</blockquote>
</li>
<li>函数差值搞一下：25-12&#x3D;(9-1)a<br>a&#x3D;13，b顺理成章等于4</li>
<li>然后google找个求逆元的网站得到逆元等于5<br>得到解密函数D(x) &#x3D; 5(x-4)%32</li>
</ul>
<p>通过解密得到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">密文：MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI</span><br><span class="line">明文：IJEVIU2DKRDHWUZSKZ4VSMTUN5RDEWTNPU</span><br></pre></td></tr></table></figure>

<p>最后base32解码就能得到flag:</p>
<blockquote>
<p>BITSCTF{S2VyY2tob2Zm}</p>
</blockquote>
]]></content>
      <categories>
        <category>CTF题解——crypto</category>
      </categories>
      <tags>
        <tag>仿射密码</tag>
      </tags>
  </entry>
  <entry>
    <title>Base64编码</title>
    <url>/2022/09/06/Base64/</url>
    <content><![CDATA[<h3 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h3><ol>
<li><p>将目标字符依照ASCII码表变为纯二进制</p>
</li>
<li><p>按每6位一个单元进行重新切割，（不够6位的地方补0）</p>
</li>
<li><p>对照base64编码表，编码出每个单元所代表的字符</p>
</li>
</ol>
<h3 id="base64编码表"><a href="#base64编码表" class="headerlink" title="base64编码表"></a>base64编码表</h3><p><img src="https://s2.loli.net/2022/09/06/QiUuEKzCvZIFNDV.jpg" alt="v2-ff0ffbecbd68704bf1ddf8f7d53095b8_r.jpg"></p>
<h3 id="eg："><a href="#eg：" class="headerlink" title="eg："></a>eg：</h3><ul>
<li><p>目标字符：dlw</p>
</li>
<li><p>第一步：转变为二进制串</p>
</li>
</ul>
<blockquote>
<p>01100100(d) 01101100(l) 01110111(w)</p>
</blockquote>
<ul>
<li>第二步：6位切割</li>
</ul>
<blockquote>
<p>011001 | 000110 | 110001 | 110111</p>
</blockquote>
<ul>
<li>第三步：查找每一单元对应的字符，重新编码</li>
</ul>
<blockquote>
<p>011001(Z) | 000110(G) | 110001(x) | 110111(3)</p>
</blockquote>
<ul>
<li>得到结果：ZGx3</li>
</ul>
<h3 id="python编码"><a href="#python编码" class="headerlink" title="python编码"></a>python编码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">base64</span></span><br><span class="line">s = input()</span><br><span class="line">t = base64.b64encode(s.encode())</span><br><span class="line"><span class="built_in">print</span>(t.decode())</span><br></pre></td></tr></table></figure>

<h3 id="python解码"><a href="#python解码" class="headerlink" title="python解码"></a>python解码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">base64</span></span><br><span class="line">s = input()</span><br><span class="line">t = base64.b64decode(s.encode())</span><br><span class="line"><span class="built_in">print</span>(t.decode())</span><br></pre></td></tr></table></figure>

<h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h3><ol>
<li><p>base64的特征之一：结果串长度一定为4的倍数</p>
</li>
<li><p>为了补齐4倍的单元，编码时可能会出现末尾n个单元全部为空的情况，这时候就用“&#x3D;”补齐，这也是识别base64编码的一种方式</p>
</li>
</ol>
<h4 id="比如两个字符“dl”"><a href="#比如两个字符“dl”" class="headerlink" title="比如两个字符“dl”"></a>比如两个字符“dl”</h4><ul>
<li><p>二进制：01100100(d) 01101100(l)</p>
</li>
<li><p>切割：011001(Z)) | 000110(G) | 1100（补两个0）(w) | （空单元）(&#x3D;)</p>
</li>
<li><p>结果：ZGw&#x3D;</p>
</li>
</ul>
<h3 id="涉及题目"><a href="#涉及题目" class="headerlink" title="涉及题目"></a>涉及题目</h3><ul>
<li>python-trade</li>
</ul>
]]></content>
      <categories>
        <category>CTF———知识点</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>仿射密码(单表加密)</title>
    <url>/2022/09/06/Affine/</url>
    <content><![CDATA[<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li>简单来说就是利用加密函数将一个字母映射为另一个字母</li>
</ul>
<h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h3><h4 id="E-x-x3D-ax-b-n-其中"><a href="#E-x-x3D-ax-b-n-其中" class="headerlink" title="E(x) &#x3D; (ax+b)%n,其中"></a>E(x) &#x3D; (ax+b)%n,其中</h4><ul>
<li>n为所设置的字母编码表的大小</li>
<li>a,b为自选数，只要满足a与n互质即可</li>
<li>x为明文编码后的数字</li>
</ul>
<h3 id="解密函数"><a href="#解密函数" class="headerlink" title="解密函数"></a>解密函数</h3><h4 id="D-x-x3D-a-1-x-b-n"><a href="#D-x-x3D-a-1-x-b-n" class="headerlink" title="D(x) &#x3D; a-1(x-b)%n"></a>D(x) &#x3D; a<sup>-1</sup>(x-b)%n</h4><ul>
<li>a<sup>-1</sup>是a在Z<sub>n</sub>群的乘法逆元</li>
</ul>
<blockquote>
<p>乘法逆元这个东西等后续完全搞懂了再解释，主要的一点是满足a<sup>-1</sup>*a%n&#x3D;1</p>
</blockquote>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>字母编码表就按ABC来，a取7，b取3,通过某在线模逆元计算器可得a<sup>-1</sup>&#x3D;15<br><img src="https://s2.loli.net/2022/09/06/mIWkYnr3jJP6Tgw.jpg" alt="Screenshot 2022-09-06 210756.jpg"></p>
<h3 id="涉及题目"><a href="#涉及题目" class="headerlink" title="涉及题目"></a>涉及题目</h3><ul>
<li><a href="http://woodenmandu.cn/2022/09/06/Affine/">BITSCTF2017 - fanfie</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF———知识点</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
</search>
